% calc_chi1_mmp.m%   Usage: called by batchprocess1_mmp%   Function: process th1 and th1 for chiif drop_flag==1 % start outer loop	% set up output arrays	chi1=NaN*ones(neps,1); kcth1=NaN*ones(neps,1); 	% chi2=NaN*ones(neps,1); kcth2=NaN*ones(neps,1); 	pr_chi=pr_eps;	% arrays for saving th1 tgrad spectra	if strcmp(save_chi_spec,'y')==1 | strcmp(save_chi_spec,'yes')==1		Ptg1=NaN*ones(eps_step/2,neps); ktg1=NaN*ones(eps_step/2,neps);	end	for i=1:1 % start loop for th1 and th2		if i==1			ch=['th1'];		elseif i==2			ch=['th2'];		end			% read configuration		[sensorid,electronicsid,filter,fc,scanpos] = read_chconfig_mmp(ch,mmpid,drop);			if strcmp(sensorid,'[]')==1			data_flag=0;			break		else			data_flag=1;			% calculate frequency-dependent circuit functions that apply to entire			% profile			%			% calculate electronics transfer fcn of th circuit and get parameters			% of the tl circuit that are needed to compute beta			str1=['[helectronics,Gtl,E1]=h' electronicsid '_mmp(f);'];			eval(str1);			%			% calculate the amplitude-squared response of the th anti-alias filter			% (the phase is empty)			str1=['[hfilt,pfilt]=' filter '(f,fc);'];			eval(str1)			%			% calcuate an array with the thermistor sensitivity for all chi windows			str1=['beta_thermistor=beta_' electronicsid '_mmp(t,tl1V,Gtl,E1);'];			eval(str1)			beta_thermistor_sq=beta_thermistor.^2; 			%			hth=helectronics .* hfilt; % all of response except thermistor			algorithm = read_algorithm_mmp(ch,drop);		end			if data_flag==1 % start data processing loop			% read raw data & convert to volts			rawdata=read_rawdata_mmp(ch,drop,scanid,scanpos);			rawdata=atod1_mmp(rawdata);					for j=1:neps % start loop for chi estimates				speed=w(j);				start_sample=(j-1)*(eps_step/2)+1;				stop_sample=start_sample+eps_step-1;						% select rawdata and take spectrum				data=rawdata(start_sample:stop_sample);				P=psd(data,eps_step,FS_hf);				P=P'/(0.5*FS_hf); % normalize to preserve variance				P=P(2:length(P)); % drop 0 frequency estimate						% determine cutoff frequency for integration				str=['fc_index=' algorithm '_' electronicsid '_mmp' ...			         '(f,P,displ_chi_spec,pr_chi(j),j,speed);'];				eval(str)							% scale with wavenumber				kc=f(fc_index)/speed;				k=f./speed; dk=df/speed;				[hsq_thermistor,phase_thermistor]=h_fp07(f,speed);				h_th_total=hth .* hsq_thermistor * beta_thermistor_sq(j);				Ptempk=(P*speed)./h_th_total';				Ptgradk=(2*pi*k').^2 .* Ptempk;				chi=6*ktemp(j)*dk.*sum(Ptgradk(1:fc_index));				if i==1					chi1(j)=chi; kcth1(j)=kc;				elseif i==2					chi2(j)=chi; kcth2(j)=kc;				end				if strcmp(save_chi_spec,'yes')==1 | strcmp(save_chi_spec,'y')==1					Ptg1(:,j)=Ptgradk'; ktg1(:,j)=k;				end			end % end loop for chi estimates		end % end data processing loop	end % end for i loop for th1 and th2	out_file=[procdata ':' cruise ':chi:chi' num2str(drop) '.mat'];	str=['save ' setstr(39) out_file  setstr(39) ' pr_chi chi1 kcth1'];	eval(str)	% write th1 spectra and cutoffs to disk if specified			if strcmp(save_chi_spec,'yes')==1 | strcmp(save_chi_spec,'y')==1		out_file=[procdata ':' cruise ':chi:Ptg1' num2str(drop) '.mat'];		str=['save ' setstr(39) out_file  setstr(39) ' Ptg1 ktg1'];		eval(str)		clear Ptg1 ktg1	end	clear sensorid electronicsid filter fc scanpos calid str str1 ...   	hfilt pfilt beta_thermistor_sq helectronics hfilt hth  algorithm rawdata data ...	start_sample stop_sample P speed k dk h_th_total Ptempk Ptgradk chi ...	 kcth1   Gtl E1 beta_thermistor phase_thermistor hsq_thermistor f ...	ktempend % end outer loop
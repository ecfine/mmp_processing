% calc_prscan3G_mmp_wREV.m  (retain pr_scans past stop_scan, do not NaN)%   Usage: Called within batchprocess4G_mmp, starting with drop 7700 (2nd round)%   Function: Calculate gauge pressure, fallrate; log time,pressure of%		steady descent and mid-drop pressure reversals.%	Input:	drop, cruise, FS_lf, procdata(from mmpfolders)%	It creates and saves:		%			pr_scan:	gauge pressure (vector)%			time: elapsed time for scans (vector)%				[pr_scan,time saved in pr<drop>.mat]%			nscans: number of scans (integer)%			w: fallrate (changed from bwd-difn(1) to center-dfn(+/-2) jun-2000)%			stop_scan: last useful scan (integer)%        pmin, pmax: pressure limits (absolute extrema)%		Also (added jun-2000):%			pBEG, tBEG: pres,time at start of steady descent (into mmplog.mat)%			pEND, tEND: pres,time at end of steady descent (into mmplog.mat)%					Sets 'data_quality' field, mmplog(:,9)=1, if steady descent. %			pREV, tREV: pres,time of reversals between tBEG and tEND -%				recorded in pr_rev<drop>.mat if any exist (then variables cleared)%%	All pressures refer to depth at pr-gauge%%  Modifies processing of calc_prscan2_mmp.m by detecting range of steady%	descent, rather than just min,max(pr), and of pressure reversals.%	Also, does not re-write existing pr<drop>.mat or mmplog.mat if drop_flag=2%	Dave Winkel - June 2000if drop_flag==1 | drop_flag==2   pr_fil = [procdata filesep cruise filesep 'pr' filesep 'pr' int2str(drop) '.mat'];   log_fil = [procdata filesep  cruise filesep 'mmplog'];   pr_scan=[]; time=[];      if drop_flag==2 & exist(pr_fil)==2      load(pr_fil); % retrieve existing pressure,time data      nscans = length(pr_scan);   else      % read name of pressure algorithm & call      algorithm=read_algorithm_mmp('pr',drop);      str=['pr_scan=' algorithm '_mmp(drop);'];      eval(str)      nscans=length(pr_scan);      % Calculate a vector of scan times      time=(1:nscans)/FS_lf; time=time(:);      % Save pressure and time records       if isempty(pr_scan)         disp(['No pressure, terminate further processing of drop' num2str(drop)])         drop_flag=0;      else         save(pr_fil, 'pr_scan', 'time');      end   end     if drop_flag>0         %% Compute fall rates   dNH = 2; % for center-difn fall rate, compute using points +/-dNH away   clear px tx    px = pr_scan; tx = time;   fp = dNH+1; lp = length(px)-dNH;   dz = ( px(fp+dNH:lp+dNH) - px(fp-dNH:lp-dNH) ) * 100;   dt = ( tx(fp+dNH:lp+dNH) - tx(fp-dNH:lp-dNH) );   for i = dNH-1:-1:1 % use fewer points near ends      x(1)=( px(2*i+1)-px(1) )*100; x(2)=( px(end)-px(end-2*i) )*100;      y(1)=( tx(2*i+1)-tx(1) );  y(2)=( tx(end)-tx(end-2*i) );      dz = [x(1); dz; x(2)];  dt = [y(1); dt; y(2)];   end   % fwd/bwd difn at ends   dz = [ (px(2)-px(1))*100; dz; (px(end)-px(end-1))*100 ];   dt = [ tx(2)-tx(1); dt; tx(end)-tx(end-1) ];   w = dz./dt; % FALL RATES (down>0) aligned with pr_scan,time   dwdt = diff(w)./diff(tx); dwdt = [dwdt(1); dwdt]; % bwd difn accel      clear x y dz dt fp lp dNH   %% SKIP to END if drop_flag=2 and min,max,reversal pr,time's already recorded      load(log_fil)   irow=find(mmplog(:,1)==drop);   pBEG = mmplog(irow,7); tBEG = mmplog(irow,12);   pEND = mmplog(irow,8); tEND = mmplog(irow,13);   %% Find begin,end of (mainly) steady descent, record in mmplog.mat;   %		then check for mid-drop reversals interrupting steady descent   if ( isnan(pBEG)&isnan(tBEG)&isnan(pEND)&isnan(tEND) ) | drop_flag==1      % pDOWN = 0.03; % maximum start-of-drop pressure (SC99 value)      pDOWN = 0.03; % maximum start-of-drop pressure      pDend = 0.02; % start checking for end-of-drop this far before max-pressure;      % i.e., reversals above pMAX-pDend are ignored here, but recorded later      wREV = 0.03; % fall rates <= wREV are considered upward (slightly>0)            ix = find(px>=pDOWN); ix=[ix; 1]; % (in case of very short drop)      tDOWN=tx(ix(1)); % first time past pDOWN            [pMAX iMAX] = max(px); % find points beyond when max pressure attained      if iMAX<length(px)         px(iMAX+1:end) = NaN; % to exclude post-drop ascent      end            iDWb = find(w<=wREV & px<pDOWN); % find start of steady descent      if isempty(iDWb) iDWb=1; else iDWb=iDWb(end)+1; end            iDWe = find(w<=wREV & px>pMAX-pDend); % find first end-of-drop stoppage      if isempty(iDWe) iDWe=iMAX; else iDWe=iDWe(1)-1; end      if iDWe<=iDWb         iDWe=iDWb;         disp(['calc_prscan3G_mmp.m - NO DOWNWARD DATA for drop ' num2str(drop)]);      end            % if iMAX-iDWe>6 disp(-drop), end % started up, then went <pDend deeper            pBEG = px(iDWb); tBEG = tx(iDWb);      pEND = px(iDWe); tEND = tx(iDWe);      %% Save limits in mmplog      mmplog(irow,7)=pBEG; mmplog(irow,12)=tBEG;      mmplog(irow,8)=pEND; mmplog(irow,13)=tEND;      mmplog(irow,9) = 0; % drop has some data      % If at least some descent is detected, flag as good drop (for now)      if tEND>tBEG+1 & pEND>pBEG+0.01         mmplog(irow,9) = 1;      end      % Synch errors, count and save in log (new, 27-mar-2003, DPW)      sc = read_rawdata_mmp('sc',drop) / 4; %  scanno in bits 2:13 of 0:15      dsc = mod(diff(sc),4096); % scan count is modulo 2^12      mmplog(irow,15) = length( find(dsc~=1) ); clear sc dsc      save(log_fil, 'mmplog');            %% Now, find reversals between start(down) and stop(up) times      iREV = find( w<=wREV & tx>tBEG & tx<=tEND );      tREV=[]; pREV=[];      if ~isempty(iREV)         drev = diff(iREV);         % find start,end times of reversals         ix = find(drev>10); % ignore short (0.5-s) "un"-reversals         iy = 1; % start of first one         for ia=1:length(ix)            iy = [iy; ix(ia); ix(ia)+1]; % end of one, start of next         end         iREV = [iREV(iy); iREV(end)]; % (add end of last one)         ix=length(iREV);         if mod(ix,2)>0  iREV = [iREV; iREV(end)]; end % (just in case)         tREV(:,1) = tx(iREV(1:2:end-1)); pREV(:,1) = px(iREV(1:2:end-1));         tREV(:,2) = tx(iREV(2:2:end)); pREV(:,2) = px(iREV(2:2:end));         % save pres,time limits of reversals         save([procdata filesep  cruise filesep 'problems' filesep 'pr_rev' int2str(drop)], ...            'pREV','tREV');      end % of reversal detection, recording   end % of detection of start,stop times,pressures of steady descent      clear px tx ix iy irow pDOWN pDend wREV iD* pREV tREV iREV drev ia      %%%%%%%%%   % Determine absolute minimum and maximum pressures (for backwards compatable)   % (But, no longer record THESE in mmplog.mat - see above)   pmin = min(pr_scan);   [pmax, stop_scan] = max(pr_scan);   % For subsequent processing, place NaN's past deepest pressure (mmp ascending).   % NO! DISABLE in this version:    % pr_scan(stop_scan+1:nscans)=NaN*ones(nscans-stop_scan,1);      clear mmplog algorithm pr_fil log_fil str  end % of: if drop_flag>0end
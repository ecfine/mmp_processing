#include <stdio.h>#include "mex.h"typedef short Boolean;#define true 1#define false 0#define SCANCOUNTERSIZE	2#define SCANBUFSIZE		8192#define	DATABUFSIZE		8192void GetScanCounter (char *data, long index, unsigned short *value){	unsigned short	lsb;	unsigned short	msb;		msb = (unsigned char) *(data+index);	lsb = (unsigned char) *(data+index+1);	*value = msb<<8 | lsb;} /* GetScanCounter */Boolean ScanCounterOK (unsigned short value){	if ( value & 0xc003 ) {		return false;	}	return true;} /* ScanCounterOK */Boolean ScanOK (char *data, long index, long scanSize){	unsigned short	sc0;	unsigned short	sc1;		GetScanCounter(data, index, &sc0);	if ( ScanCounterOK(sc0) == false ) {		return false;	}	GetScanCounter(data, index + scanSize, &sc1);	if ( ScanCounterOK(sc1) == false ) {		return false;	}	if ( sc1 != ((sc0+4) & 037774) ) {		return false;	}	return true;} /* ScanOK */Boolean SyncedToData (char *data, long index, long scanSize){	long	i;		for (i = 0; i < (5 * scanSize); i += scanSize) {		if ( ScanOK(data, index+i, scanSize) ) {			continue;		} else {			return false;		}	}	return true;} /* SyncedToData */int dmx (FILE *inputFp, FILE *outputFp, char *scanBuf, char *dataBuf,	short *offsetList, short offsetCount, long scanSize){	size_t		readCount;	long		total = 0;	long		i;	long		j;	long		scanBufCount;	long		scanCounterSize = 2;	Boolean		scanBufSynced;		scanBufSynced = false;	scanBufCount = 0;	i = 0;	for (;;) {		if ( scanBufSynced ) {			if ( i+scanSize+SCANCOUNTERSIZE > scanBufCount ) {				for (j = 0; i < scanBufCount; i++, j++) {					*(scanBuf+j) = *(scanBuf+i);				}				scanBufCount = j;				i = 0;				readCount = fread(scanBuf+scanBufCount, sizeof(char),					SCANBUFSIZE-scanBufCount, inputFp);				if ( readCount < 1 ) {					/*mexPrintf("%d scans\n", total);*/					return 0;				}				scanBufCount += readCount;				continue;			}			if ( ScanOK(scanBuf, i, scanSize) ) {				total += 1;				/*	copy data */				for (j = 0; j < offsetCount; j++) {					*(dataBuf+j) = *(scanBuf + i + *(offsetList + j));				}				if ( fwrite(dataBuf, sizeof(char), j, outputFp) != j ) {					mexPrintf("DMX unable to write to output file\n");					return 1;				}				i += scanSize;			} else {				scanBufSynced = false;			}		} else {			/* sync with the data */			for (;;) {				if ( (5 * scanSize + SCANCOUNTERSIZE + i ) > scanBufCount ) {					for (j = 0; i < scanBufCount; i++, j++) {						*(scanBuf+j) = *(scanBuf+i);					}					scanBufCount = j;					i = 0;					readCount = fread(scanBuf+scanBufCount, sizeof(char),						SCANBUFSIZE-scanBufCount, inputFp);					if ( readCount < 1 ) {						/*mexPrintf("%d scans\n", total);*/						return 0;					}					scanBufCount += readCount;					continue;				}				if ( SyncedToData(scanBuf, i, scanSize) ) {					scanBufSynced = true;					break;				} else {					i++;				}			}		}	}	return 0;} /* dmx */void mexFunction (int nlhs, Matrix *plhs[], int nrhs, Matrix *prhs[]){	char	*inputFileName;	char	*outputFileName;	short	*offsetList;	short	offsetCount;	long	scanSize;	FILE	*inputFp;	FILE	*outputFp;	char	*inputFileBuffer;	char	*outputFileBuffer;	char	*scanBuf;	char	*dataBuf;	long	i;	double	*p;	/*	check number of arguments */	if ( nlhs != 0 || plhs[0] != NULL ) {		mexErrMsgTxt("DMX does not return arguments.");	}	if ( nrhs != 4 ) {		mexErrMsgTxt("DMX requires four arguments.");	}	/*	file names */	if ( mxIsString(prhs[0]) != 1 || mxIsString(prhs[1]) != 1 ) {		mexErrMsgTxt("DMX requires the first and second arguments to be strings.");	}	inputFileName = mxCalloc(256, sizeof(char));	outputFileName = mxCalloc(256, sizeof(char));		mxGetString(prhs[0], inputFileName, 256);	mxGetString(prhs[1], outputFileName, 256);	/*	scan size */	if ( mxIsNumeric(prhs[2]) != 1 || mxGetM(prhs[2]) != 1 || mxGetN(prhs[2]) != 1 ) {		mexErrMsgTxt("DMX requires the third argument to be a scalar.");	}	scanSize = (long) mxGetScalar(prhs[2]);	if ( scanSize < SCANCOUNTERSIZE ) {		mexErrMsgTxt("DMX requires third argument to be greater than 1.");	}	/*	offsets */	if ( mxIsNumeric(prhs[3]) != 1 ) {		mexErrMsgTxt("DMX requires the fourth argument to be a vector.");	}	if ( mxIsComplex(prhs[3]) == 1 ) {		mexErrMsgTxt("DMX requires the fourth argument not to be a complex vector.");	}	if ( mxIsFull(prhs[3]) != 1 ) {		mexErrMsgTxt("DMX requires the fourth argument to be a full vector.");	}	if ( mxIsDouble(prhs[3]) != 1 ) {		mexErrMsgTxt("DMX requires the fourth argument to be a double-precision vector.");	}	if ( mxGetM(prhs[3]) < 1 || mxGetN(prhs[3]) < 1 ) {		offsetCount = 0;		offsetList = NULL;	} else {		if ( mxGetM(prhs[3]) > 1 && mxGetN(prhs[3]) > 1 ) {			mexErrMsgTxt("DMX requires the fourth argument to be a vector.");		}		if ( mxGetN(prhs[3]) > 1 ) {			offsetCount = mxGetN(prhs[3]);		} else {			offsetCount = mxGetM(prhs[3]);		}		offsetList = mxCalloc(offsetCount, sizeof(short));		p = mxGetPr(prhs[3]);		for (i = 0; i < offsetCount; i++) {			offsetList[i] = (short) *(p+i);		}	}		/*	allocate buffers */	inputFileBuffer = mxCalloc(16384, sizeof(char));	outputFileBuffer = mxCalloc(16384, sizeof(char));		scanBuf = mxCalloc(SCANBUFSIZE, sizeof(char));	dataBuf = mxCalloc(DATABUFSIZE, sizeof(char));	/*	open files */	if ( (inputFp = fopen(inputFileName, "r")) == NULL ) {		mexErrMsgTxt("DMX unable to open input file.");	}	if ( (outputFp = fopen(outputFileName, "w")) == NULL ) {		(void) fclose(inputFp);		mexErrMsgTxt("DMX unable to open output file.");	}	/*	set file buffers */	if ( setvbuf(inputFp, inputFileBuffer, _IOFBF, 16384) != 0 ) {		(void) fclose(inputFp);		(void) fclose(outputFp);		mexErrMsgTxt("DMX unable to set buffer for input file.");	}	if ( setvbuf(outputFp, outputFileBuffer, _IOFBF, 16384) != 0 ) {		(void) fclose(inputFp);		(void) fclose(outputFp);		mexErrMsgTxt("DMX unable to set buffer for output file.");	}		/*	demux data */	if ( dmx(inputFp, outputFp, scanBuf, dataBuf, offsetList, offsetCount, scanSize) != 0 ) {		(void) fclose(inputFp);		(void) fclose(outputFp);		mexErrMsgTxt("DMX computational routine failed to complete normally.");	}		/*	close files */	if ( fclose(inputFp) != 0 ) {		(void) fclose(outputFp);		mexErrMsgTxt("DMX unable to close input file.");	}		if ( fclose(outputFp) != 0 ) {		mexErrMsgTxt("DMX unable to close output file.");	}} /* mexFunction */